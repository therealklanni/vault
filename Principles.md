# Principles of using the Brave Vault
The Brave _vault_ is a mediation server for your browsing activities as they relate to advertisements.
Because you may use multiple browsers,
the vault also allows browsers to sync data.

The vault is carefully designed so as to "know" as little as possible about you and your browsing habits.
In order to understand the limitations of this design,
we need to examine the basic principles of the vault.

## Personas and Sessions
The central data element in the vault is a _persona_ -- sometimes referred to as a _user_ of the system.
A persona is meant to identify a set of your browsing behaviors,
without identifying you.
Each Brave-capable browser is free to create its own persona,
or to use an existing persona created by another browser.

If you configure the same persona for multiple browsers
(e.g., your desktop at work, your tablet at home, your phone when mobile),
then this provides a more complete picture of your browsing activities.
You may view this as a good thing or a bad thing -- and that's fine -- you decide.

### Creating a Persona
The `PUT /v1/users/{userId}` operation both
creates an entry for a persona,
and updates the information in that entry.
A `userId` is a 122-bit pseudo-random number commonly known as a
[UUID v4](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29) value.
Note that it is generated by the browser,
not the server.
For example,
[Stack Overflow](http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript#2117523)
gives a browser-based example:

    'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = window.crypto.getRandomValues(new Uint8Array(1))[0]%16|0, v = c == 'x' ? r : (r&0x3|0x8)
        return v.toString(16).toUpperCase()
    })

In addition to generating the `userId`,
the browser generates a `masterKey` and a `signingPair`:

    window.crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true
                                    , ['encrypt', 'decrypt']).then(function (masterKey) { ... })

    window.crypto.subtle.generateKey({ name: 'ECDSA', namedCurve: 'P-256' }, true
                                    , [ 'sign', 'verify' ]).then(function (signingPair) { ... })

Both the `masterKey` and `signingPair.privateKey` must be securely persisted in the browser.

When creating a persona,
the HTTP body is:

    { header      :
      { signature : '...'
      , nonce     : '...'
      }
    , payload     :
      { version   : 1
      , publicKey : '...'
      }
    }

The `version` property is self-explanatory.

The `publicKey` property is the hexadecimal string representation of the public key used to verify digital signatures.
The vault verifies the signature as the authorization check for an operation.

The `signature` and `nonce` properties are used to ensure that the client actually knows the `signing.privateKey`:

    var to_hex = function (bs) {
        var encoded = []
        
        for (var i = 0; i < bs.length; i++) {
            encoded.push('0123456789abcdef'[(bs[i] >> 4) & 15])
            encoded.push('0123456789abcdef'[bs[i] & 15])
        }
        return encoded.join('')
    }
        
    var ab2b = function (ab) {
        var buffer = []
        var view = new Uint8Array(ab)
        
        for (var i = 0; i < ab.byteLength; i++) buffer[i] = view[i]
        return buffer
    }
        
        
    // note that the publicKey is not sent as an x/y pair, but instead is a concatenation (the 0x04 prefix indicates this)
    window.crypto.subtle.exportKey('jwk', pair.publicKey).then(function (publicKey) {
        var message = { header      : {}
                      , payload     : 
                        { version   : 1
                        , publicKey: '04' +
                                     new Buffer(publicKey.x, 'base64').toString('hex') +
                                     new Buffer(publicKey.y, 'base64').toString('hex')
                        }
                      }
        var nonce = (new Date().getTime() / 1000).toString()
        var combo = JSON.stringify({ userId: userId, nonce: nonce, payload: message.payload })
        window.crypto.subtle.sign({ name: 'ECDSA', namedCurve: 'P-256', hash: { name: 'SHA-256' } },
                                  pair.privateKey, s2ab(combo)).then(function(signature) {
            message.header = { signature: to_hex(ab2b(signature)), nonce: nonce }

            console.log('PUT /v1/users/' + userId)
            console.log(JSON.stringify(message, null, 2))
        })
    })

In order for the `nonce` to be considered valid,
it must be "close" to the vault's notion of the current time.
In order to avoid time synchronization issues,
the vault will include its own `nonce` property in the results of these operations:

    GET /v1/ping

    GET /v1/users/{userId}
    PUT /v1/users/{userId}

    GET /v1/users/{userId}/sessions
    GET /v1/users/{userId}/sessions/{sessionId}/types    
    GET /v1/users/{userId}/sessions/{sessionId}/types/{type}
    PUT /v1/users/{userId}/sessions/{sessionId}/types/{type}

The browser is responsible for correlating this value to its own notion of the current time,
e.g.,

    var offset = result.header.nonce - new Date().getTime()
    ...
    var nonce = new Date().getTime() + offset

(YZ: I think the part above is okay for now, but there is a good chance we will
be able to get real network time through a separate protocol/API more easily,
so nonce in the server response might not be necessary. Also, maybe should be
renamed to "timestamp" because network time will be used for other purposes like
conversion tracking.)

To summarize:

* Whenever the browser stores something encrypted in the vault,
it encrypts data using the `masterKey` and a one-time initialization vector.
The `masterKey` is never stored in the vault:
only the browser that created the persona
-- along with any other browsers that you configure to be authorized --
are able to decrypt the actual value.

* Whenever the browser stores something in the vault,
it uses the `signingPair.privateKey` to generate a signature over a hashed value to allow the vault to determine if
the browser is authorized.

### Creating a Session
In addition to selecting a persona,
a browser must also create a _session_.
As with the `userId`,
a `sessionId` is a UUID v4 string that is generated by the browser.

Although the browser determines the lifetime of the session -- the common practice is for each client to to generate
a lifetime `sessionId`.
The reason is that the `sessionId` is used as a key to store browser-specific information such as history.

[YZ: 'key' in the encryption sense or in the data structure sense? I assume the latter.]

The `PUT /v1/users/{userId}/sessions/{sessionId}/types/{type}` operation
creates or updates that `type` of information for that particular session of the persona.


### Joining a Persona
When the user wishes to configure an additional browser (the "new" browser)
to use the same persona in use by an existing browser (the "old" browser),
the "new" browser needs to be told:

* the persona-identifier (`userId`)

* the `masterKey`

* the `signingPair.privateKey`

The easiest way to do this is to have the "old" browser generate a [QR code](https://en.wikipedia.org/wiki/QR_code)
of the form:

    brave://vault/persona/{userId}?m={masterkey}&p={signingPair.privateKey}

[YZ: Should this URI be versioned?]

For example:

    var url = 'brave://vault/persona/' + userId
    window.crypto.subtle.exportKey('raw', masterKey).then(function (exportKey) {
        url += '?m=' + ab2b(exportKey)

        window.crypto.subtle.exportKey('jwk', signingPair.privateKey).then(function (exportKey) {
            url += '&p=' + encodeURIComponent(JSON.stringify(exportKey))

            console.log('QR code: ' + url)
        })
    })

<img src='data:image/jpeg;base64,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' width='405' height='405' />

Once the QR code is generated,
the "new" browser can use its camera and a QR decoder to derive the three elements pertaining to the persona.

If the "new" browser does not have a camera,
then the "old" browser should save a file to a USB stick on its platform,
which is subsequently moved to the platform with the "new" browser,
imported in to the "new" browser,
and then wiped:

    window.crypto.subtle.exportKey('raw', masterKey).then(function (m) {
        window.crypto.subtle.exportKey('jwk', pair.privateKey).then(function (p) {
            var format = { version    : 1
                         , personaURL : 'brave://vault/persona/' + userId
                         , masterKey  : to_hex(ab2b(m))
                         , privateKey : p
                         }
            console.log(JSON.stringify(format, null, 2))
        })
    })

[YZ: I think the % of users who have a USB stick around at all times and know how to properly wipe it afterwards is pretty small. We can come up with a fancier camera-less device pairing protocol (like what Firefox sync used to do) after V1.]

For example:

    { version    : 1
    , personaId  : 'brave://vault/persona/D7AE8B62-7D59-4417-B335-209B766D09D1'
    , masterKey  : '3f9bf659d1e469025006bc20885dd0ef445229a585a65d3d5d2d4a1514fc1d36'
    , privateKey :
      { crv      : 'P-256'
      , d        : 'm5_ZKjR64DK-t4WzIrsKcRQhcKZwJf1BGjv9P0MAiS0'
      , ext      : true,
      , key_ops  : [ 'sign' ]
      , kty      : 'EC'
      , x        : 'VY2NyRpYRPQ2onuDFdzmfZ8fACyYTWsjZTO_gb5eN_0'
      , y        : 'Yrex6N1BEflazfIP3OEy7_2J2v7ZCTParAFelMF_WqA'
      }
    }

## Managing State
The vault manages two kinds of state:

* session state, that is session-specific; and,

* global state, that is session-independent.

It is up to the browser to determine which kind of state to associated with browser-specific data.

### Session State
The `GET /v1/users/{userId}/sessions` operation returns an array of all state for all of the sessions for the persona.
Because there may be many results,
the operation has two optional `GET query` parameters,
`limit` and `timestamp`.

The `limit` parameter indicates the maximum number of entries to return.

The `timestamp` parameter is an opaque string.
On the first call to `GET /v1/users/{userId}/sessions`,
the parameter isn't specified.
On subsequent calls,
the value should be equal to the `timestamp` property of the final element in the results array.
Eventually,
the results array will be zero-length,
and all entries have been returned.

The `GET /v1/users/{userId}/sessions/{sessionId}/types` operation returns an array of all state for a particular
session of the persona.
The operation has two optional `GET query` parameters,
`limit` and `timestamp`,
with the usual semantics.

The `GET /v1/users/{userId}/sessions/{sessionId}/types/{type}` operation returns the state of for a particular
`type` of information for that particular session of the persona.

The `PUT /v1/users/{userId}/sessions/{sessionId}/types/{type}` operation creates or updates that `type` of information for
that particular session of the persona.

When upserting state information,
the HTTP body is:

    { header          :
      { signature     : '...'
      , nonce         : '...'
      },
    , payload         :
      { iv            : '...'
      , encryptedData : '...'
      }
    }

For example:

    var s2ab = function (s) {
        var buffer = new Uint8Array(s.length)

        for (var i = 0; i < s.length; i++) buffer[i] = s.charCodeAt(i)
        return buffer
    }

    var history = { ... }

    var iv = window.crypto.getRandomValues(new Uint8Array(12))
    window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv },
                                 masterKey, s2ab(JSON.stringify(history))).then(function(encryptedData) {
    var message = { header          : {}
                  , payload         :
                    { iv            : to_hex(iv)
                    , encryptedData : to_hex(ab2b(encryptedData))
                    }
                  }
        var nonce = (new Date().getTime() / 1000).toString()
        var combo = JSON.stringify({ userId: userId, nonce: nonce, payload: message.payload })
        window.crypto.subtle.sign({ name: 'ECDSA', namedCurve: 'P-256', hash: { name: 'SHA-256' } },
                                  signingPair.privateKey, s2ab(combo)).then(function(signature) {
            message.header = { signature: to_hex(ab2b(signature)), nonce: nonce }

            console.log('PUT /v1/users/' + userId + '/sessions/' + sessionId + '/types/history')
            console.log(JSON.stringify(message, null, 2))
        })
    })

In some cases,
the browser may want the vault to be able to see the contents:

    var message = { header      : {}
                  , payload     : 
                    { sessionId : sessionId
                    , type      : 'browser.app.launch'
                    , timestamp : new Date().getTime()
                    , data      : {}
                    }
                  }
    var nonce = (new Date().getTime() / 1000).toString()
    var combo = JSON.stringify({ userId: userId, nonce: nonce, payload: message.payload })
    window.crypto.subtle.sign({ name: 'ECDSA', namedCurve: 'P-256', hash: { name: 'SHA-256' } },
                              signingPair.privateKey, s2ab(combo)).then(function(signature) {
        message.header = { signature: to_hex(ab2b(signature)), nonce: nonce }

        console.log('POST /v1/users/' + userId + '/intents')
        console.log(JSON.stringify(message, null, 2))
    })

Note that in both cases,
the vault verifies the digital signature in order to ensure that the operation is authorized.
The `nonce` property is a timestamp indicating the number of seconds since the UNIX epoch.
In order for the `nonce` to be considered valid,
it must be "close" to the vault's notion of the current time.
In order to avoid time synchronization issues,
the vault will include its own `nonce` property in the results of many operations.
The browser is responsible for correlating this value to its own notion of the current time,
e.g.,

    var offset = results.header.nonce - new Date().getTime()
    ...
    message.header.nonce = new Date().getTime() + offset

### Global State
The `PUT /v1/users/{userId}` operation,
in addition to creating an entry for a persona,
also updates the information in that entry.

When updating information,
the HTTP body is:

    { timestamp       : '...'
    , header          :
      { signature     : '...'
      , nonce         : '...'
      },
    , payload         :
      { iv            : '...'
      , encryptedData : '...'
      , plaintextData : { ... }
      }
    }

The procedure for generating the `header` and `payload` properties are the same,
with one exception: there is both a `payload.encryptedData` property and a `payload.plaintextData` property.
The latter is an arbitrary JSON object with plaintext information.

This operation updates information shared between all applications for the correpsonding user entry,
using an advisory locking scheme.
To successfully update the shared information,
the browser must:

1. Use the `GET /v1/users/{userId}` operation to retrieve the current information; then,

2. Modify the returned "payload" as appropriate; then,

3. Use the `PUT /v1/users/{userId}` operation with the previously-returned `timestamp` and the modified `payload`.

4. If HTTP code 422 is returned, go back to Step 1; otherwise,

5. Optionally:
locally-persist the newly-returned `timestamp`
so as to skip Step 1 the next time a state update is desired.

This allows multiple applications to (patiently) coordinate their actions in upgrading the shared information.
However, if an application must universally overwrite the shared information, it omits the "timestamp" parameter.

    var publicGlobal   = { ... }
      ,  privateGlobal = { ... }

    var iv = window.crypto.getRandomValues(new Uint8Array(12))
    window.crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv },
                                 masterKey, s2ab(JSON.stringify(privateGlobal))).then(function(encryptedData) {
        var message = { timestamp    : '...'
                      , header       : {}
                      , payload      :
                        { iv         : to_hex(iv)
                        , encryptedData : to_hex(ab2b(encryptedData))
                        , plaintextData : publicGlobal
                        }
                      }
        var nonce = (new Date().getTime() / 1000).toString()
        var combo = JSON.stringify({ userId: userId, nonce: nonce, payload: message.payload })
        window.crypto.subtle.sign({ name: 'ECDSA', namedCurve: 'P-256', hash: { name: 'SHA-256' } },
                                  signingPair.privateKey, s2ab(combo)).then(function(signature) {
            message.header = { signature: to_hex(ab2b(signature)), nonce: nonce }

            console.log('PUT /v1/users/' + userId)
            console.log(JSON.stringify(message, null, 2))
        })
    })

